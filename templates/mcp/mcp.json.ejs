<%
// Helper function to build MCP server entry
function buildMcpServer(config, defaults) {
  const result = {};

  // HTTP-based servers: url + headers
  if (config.url || defaults.url) {
    result.url = config.url || defaults.url;
    // Add type for HTTP servers
    if (defaults.type) {
      result.type = defaults.type;
    }
    // Add headers if present
    const headers = { ...(defaults.headers || {}), ...(config.headers || {}) };
    if (Object.keys(headers).length > 0) {
      result.headers = headers;
    } else {
      result.headers = {};
    }
    return result;
  }

  // stdio-based servers: command + args + env
  if (config.command) {
    result.command = config.command;
  } else if (defaults.command) {
    result.command = defaults.command;
  }

  if (config.args) {
    result.args = config.args;
  } else if (defaults.args) {
    result.args = defaults.args;
  }

  // Add type for stdio servers with explicit type
  if (defaults.type) {
    result.type = defaults.type;
  }

  // Build env object
  const envVars = { ...(defaults.env || {}) };

  // Add custom env vars
  if (config.env) {
    Object.assign(envVars, config.env);
  }

  // Handle custom path property -> maps to specific env var
  // memory_bank.path -> MEMORY_BANK_ROOT
  if (config.path) {
    envVars['MEMORY_BANK_ROOT'] = config.path;
  }

  // Add API key from api_key_env
  if (config.api_key_env) {
    const keyName = config.api_key_env.replace(/_/g, '_');
    envVars[keyName] = '${env:' + config.api_key_env + '}';
  }

  if (Object.keys(envVars).length > 0) {
    result.env = envVars;
  }

  return result;
}

// Default configurations for known MCP servers
// Token format: ${env:VAR_NAME} (not ${VAR_NAME})
const mcpDefaults = {
  // HTTP-based servers
  figma: {
    url: 'https://mcp.figma.com/mcp',
    headers: {}
  },
  hindsight: {
    url: 'http://localhost:8888/mcp/alice/'
  },
  // z.ai HTTP services (enabled via browser key)
  'web-search-prime': {
    type: 'http',
    url: 'https://api.z.ai/api/mcp/web_search_prime/mcp',
    headers: { Authorization: 'Bearer ${env:Z_AI_API_KEY}' }
  },
  'web-reader': {
    type: 'http',
    url: 'https://api.z.ai/api/mcp/web_reader/mcp',
    headers: { Authorization: 'Bearer ${env:Z_AI_API_KEY}' }
  },
  zread: {
    type: 'http',
    url: 'https://api.z.ai/api/mcp/zread/mcp',
    headers: { Authorization: 'Bearer ${env:Z_AI_API_KEY}' }
  },
  // stdio-based servers
  snyk: {
    command: 'npx',
    args: ['-y', 'snyk@latest', 'mcp', '-t', 'stdio'],
    env: {}
  },
  memory_bank: {
    command: 'npx',
    args: ['-y', '@allpepper/memory-bank-mcp'],
    env: { MEMORY_BANK_ROOT: '.memory' }
  },
  'zai-mcp-server': {
    type: 'stdio',
    command: 'npx',
    args: ['-y', '@z_ai/mcp-server'],
    env: { Z_AI_API_KEY: '${env:Z_AI_API_KEY}', Z_AI_MODE: 'ZAI' }
  },
  // Context7 - library documentation lookup
  context7: {
    command: 'npx',
    args: ['-y', '@upstash/context7-mcp'],
    env: { CONTEXT7_API_KEY: '${env:CONTEXT7_API_KEY}' }
  },
  // MCP_DOCKER - Docker MCP gateway for containerized tools
  mcp_docker: {
    type: 'stdio',
    command: 'docker',
    args: ['mcp', 'gateway', 'run']
  },
  // mcp-atlassian - Jira/Confluence integration via MCP
  'mcp-atlassian': {
    type: 'stdio',
    command: 'uvx',
    args: ['mcp-atlassian'],
    env: {
      JIRA_URL: '${env:JIRA_URL}',
      JIRA_USERNAME: '${env:JIRA_USERNAME}',
      JIRA_API_TOKEN: '${env:JIRA_API_TOKEN}'
    }
  }
};

// Server display names (key in yaml -> name in MCP config)
const mcpNames = {
  hindsight: 'hindsight-alice',
  snyk: 'Snyk',
  context7: 'Context7',
  mcp_docker: 'MCP_DOCKER',
  figma: 'Figma',
  memory_bank: 'allpepper-memory-bank',
  // browser key enables these z.ai services:
  'zai-mcp-server': 'zai-mcp-server',
  'web-search-prime': 'web-search-prime',
  'web-reader': 'web-reader',
  zread: 'zread',
  // Atlassian integration
  'mcp-atlassian': 'mcp-atlassian'
};

// Collect enabled servers
const enabledServers = [];
if (services?.mcp) {
  for (const [key, config] of Object.entries(services.mcp)) {
    if (config?.enabled) {
      // browser key enables multiple z.ai services
      if (key === 'browser') {
        // Add zai-mcp-server (stdio)
        const zaiDefaults = mcpDefaults['zai-mcp-server'];
        enabledServers.push({
          name: mcpNames['zai-mcp-server'],
          config: buildMcpServer(config, zaiDefaults)
        });
        // Add web-search-prime (http)
        enabledServers.push({
          name: mcpNames['web-search-prime'],
          config: buildMcpServer({}, mcpDefaults['web-search-prime'])
        });
        // Add web-reader (http)
        enabledServers.push({
          name: mcpNames['web-reader'],
          config: buildMcpServer({}, mcpDefaults['web-reader'])
        });
        // Add zread (http)
        enabledServers.push({
          name: mcpNames['zread'],
          config: buildMcpServer({}, mcpDefaults['zread'])
        });
      } else {
        const name = mcpNames[key] || key;
        const defaults = mcpDefaults[key] || {};
        const serverConfig = buildMcpServer(config, defaults);
        enabledServers.push({ name, config: serverConfig });
      }
    }
  }
}

// Auto-enable mcp-atlassian when task_tracking is jira with MCP integration mode
if (services?.task_tracking?.type === 'jira' && services?.task_tracking?.integration_mode === 'mcp') {
  // Check if not already added via mcp config
  const alreadyAdded = enabledServers.some(s => s.name === 'mcp-atlassian');
  if (!alreadyAdded) {
    const atlassianDefaults = mcpDefaults['mcp-atlassian'];
    const atlassianConfig = buildMcpServer({}, atlassianDefaults);
    enabledServers.push({ name: 'mcp-atlassian', config: atlassianConfig });
  }
}
-%>
{
  "mcpServers": {
<% enabledServers.forEach((server, index) => { -%>
    "<%= server.name %>": <%- JSON.stringify(server.config, null, 6).replace(/\n/g, '\n    ') %><%= index < enabledServers.length - 1 ? ',' : '' %>
<% }); -%>
  }
}
