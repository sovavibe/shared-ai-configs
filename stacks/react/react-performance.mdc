---
description: 'React performance optimization: Vercel-inspired rules ranked by impact'
version: '2.0.0'
lastUpdated: '2026-01-22'
globs: ['**/*.{ts,tsx}', 'vite.config.ts', '**/router/**/*.tsx']
alwaysApply: false
---

# React Performance Optimization Rules

Based on Vercel React Best Practices - 50+ rules across 10 categories, prioritized by impact.

**React 19 Ready** - Includes Server Components, Actions, use() hook, and React Compiler patterns.

## Core Web Vitals 2026

| Metric | Target | Warning | Critical | Notes |
|--------|--------|---------|----------|-------|
| **LCP** (Largest Contentful Paint) | < 2.5s | 2.5-4s | > 4s | Primary loading metric |
| **INP** (Interaction to Next Paint) | < 200ms | 200-500ms | > 500ms | Replaced FID in 2024 |
| **CLS** (Cumulative Layout Shift) | < 0.1 | 0.1-0.25 | > 0.25 | Visual stability |
| **TTFB** (Time to First Byte) | < 800ms | 800ms-1.8s | > 1.8s | Server responsiveness |

**INP vs FID:** INP measures ALL interactions throughout page lifecycle, not just first input. Optimize event handlers, reduce main thread blocking, use `startTransition()` for non-urgent updates.

## üî¥ CRITICAL: React 19 Performance Features

### React Compiler (Auto-Memoization)

React Compiler eliminates manual `useMemo`, `useCallback`, and `memo()` in most cases.

```typescript
// ‚úÖ React 19 with Compiler - no manual memoization needed
function ProductList({ products, onSelect }) {
  const sorted = products.toSorted((a, b) => a.name.localeCompare(b.name))
  const handleClick = (id) => onSelect(id)

  return sorted.map(p => <Product key={p.id} product={p} onClick={handleClick} />)
}

// ‚ùå Pre-Compiler pattern (still works, but unnecessary with Compiler)
function ProductList({ products, onSelect }) {
  const sorted = useMemo(() => products.toSorted((a, b) => a.name.localeCompare(b.name)), [products])
  const handleClick = useCallback((id) => onSelect(id), [onSelect])

  return sorted.map(p => <Product key={p.id} product={p} onClick={handleClick} />)
}
```

**When Compiler can't optimize:** External mutations, non-React state, `ref.current` reads during render.

### use() Hook for Async Data

```typescript
// ‚úÖ React 19 - use() unwraps promises during render
function UserProfile({ userPromise }) {
  const user = use(userPromise) // Suspends until resolved
  return <div>{user.name}</div>
}

// ‚úÖ Conditional use() - unlike hooks, can be called conditionally
function MaybeUser({ userPromise, showUser }) {
  if (!showUser) return null
  const user = use(userPromise)
  return <div>{user.name}</div>
}

// ‚ùå Old pattern - required useEffect + useState
function UserProfile({ userId }) {
  const [user, setUser] = useState(null)
  useEffect(() => {
    fetchUser(userId).then(setUser)
  }, [userId])
  if (!user) return <Spinner />
  return <div>{user.name}</div>
}
```

### Actions for Form Submissions

```typescript
// ‚úÖ React 19 Actions - automatic pending state, optimistic updates
function CommentForm({ postId }) {
  const [state, submitAction, isPending] = useActionState(
    async (prevState, formData) => {
      const comment = formData.get('comment')
      await addComment(postId, comment)
      return { success: true }
    },
    { success: false }
  )

  return (
    <form action={submitAction}>
      <input name="comment" disabled={isPending} />
      <button disabled={isPending}>{isPending ? 'Posting...' : 'Post'}</button>
    </form>
  )
}

// ‚ùå Old pattern - manual state management
function CommentForm({ postId }) {
  const [isPending, setIsPending] = useState(false)
  const handleSubmit = async (e) => {
    e.preventDefault()
    setIsPending(true)
    await addComment(postId, new FormData(e.target).get('comment'))
    setIsPending(false)
  }
  // ...
}
```

### useOptimistic for Instant Feedback

```typescript
// ‚úÖ React 19 - optimistic UI updates
function LikeButton({ likes, postId }) {
  const [optimisticLikes, addOptimisticLike] = useOptimistic(
    likes,
    (currentLikes, newLike) => [...currentLikes, newLike]
  )

  const handleLike = async () => {
    addOptimisticLike({ id: 'temp', pending: true })
    await likePost(postId) // If fails, React reverts optimistic update
  }

  return <button onClick={handleLike}>{optimisticLikes.length} Likes</button>
}
```

## üî¥ CRITICAL: Server Components & Streaming

### Server Components for Static Content

```typescript
// ‚úÖ Server Component (default in React 19 with frameworks)
// - Zero JS sent to client for this component
// - Can directly access databases, file system
async function ProductPage({ id }) {
  const product = await db.products.findOne(id) // Direct DB access
  const reviews = await db.reviews.find({ productId: id })

  return (
    <div>
      <ProductDetails product={product} />
      <Suspense fallback={<ReviewsSkeleton />}>
        <Reviews reviews={reviews} />
      </Suspense>
      <AddToCartButton id={id} /> {/* Client Component */}
    </div>
  )
}

// ‚úÖ Client Component - interactive parts only
'use client'
function AddToCartButton({ id }) {
  const [isPending, startTransition] = useTransition()
  return (
    <button onClick={() => startTransition(() => addToCart(id))}>
      {isPending ? 'Adding...' : 'Add to Cart'}
    </button>
  )
}
```

### Suspense Streaming Patterns

```typescript
// ‚úÖ Streaming with nested Suspense boundaries
function Dashboard() {
  return (
    <div>
      {/* Critical content - streams first */}
      <Suspense fallback={<HeaderSkeleton />}>
        <Header />
      </Suspense>

      <div className="grid">
        {/* Independent streams - load in parallel */}
        <Suspense fallback={<StatsSkeleton />}>
          <StatsPanel />
        </Suspense>

        <Suspense fallback={<ChartSkeleton />}>
          <RevenueChart />
        </Suspense>

        {/* Lower priority - streams last */}
        <Suspense fallback={<ActivitySkeleton />}>
          <RecentActivity />
        </Suspense>
      </div>
    </div>
  )
}

// ‚úÖ Preload pattern for anticipated navigation
import { preload } from 'react-dom'

function ProductCard({ product }) {
  const handleHover = () => {
    preload(`/api/products/${product.id}/details`, { as: 'fetch' })
    preload(product.imageUrl, { as: 'image' })
  }

  return <Link href={`/products/${product.id}`} onMouseEnter={handleHover}>...</Link>
}
```

### Progressive Enhancement with Suspense

```typescript
// ‚úÖ Show content progressively as it loads
function UserDashboard({ userId }) {
  return (
    <ErrorBoundary fallback={<ErrorMessage />}>
      {/* User info loads first (fast) */}
      <Suspense fallback={<UserInfoSkeleton />}>
        <UserInfo userId={userId} />
      </Suspense>

      {/* Stats can load independently */}
      <Suspense fallback={<StatsSkeleton />}>
        <UserStats userId={userId} />
      </Suspense>

      {/* Activity log is slowest, loads last */}
      <Suspense fallback={<ActivitySkeleton />}>
        <ActivityLog userId={userId} />
      </Suspense>
    </ErrorBoundary>
  )
}
```

## üî¥ CRITICAL: Eliminating Waterfalls

Waterfalls are the #1 performance killer. Each sequential await adds full network latency.

### Promise.all() for Independent Operations

**Impact: CRITICAL (2-10√ó improvement)**

```typescript
// ‚ùå BAD - Sequential (3x slower)
const user = await fetchUser()
const posts = await fetchPosts()
const comments = await fetchComments()

// ‚úÖ GOOD - Parallel
const [user, posts, comments] = await Promise.all([fetchUser(), fetchPosts(), fetchComments()])
```

**TanStack Query - automatic parallelization:**

```typescript
// ‚úÖ GOOD - Independent queries run in parallel
const { data: user } = useQuery({ queryKey: ['user', userId], queryFn: () => getUser(userId) })
const { data: posts } = useQuery({ queryKey: ['posts', userId], queryFn: () => getUserPosts(userId) })
const { data: comments } = useQuery({ queryKey: ['comments', userId], queryFn: () => getUserComments(userId) })
```

### Defer Await Until Needed

```typescript
// ‚ùå BAD - blocks both branches
async function handleRequest(userId: string, skipProcessing: boolean) {
  const userData = await fetchUserData(userId)
  if (skipProcessing) return { skipped: true }
  return processUserData(userData)
}

// ‚úÖ GOOD - only blocks when needed
async function handleRequest(userId: string, skipProcessing: boolean) {
  if (skipProcessing) return { skipped: true }
  const userData = await fetchUserData(userId)
  return processUserData(userData)
}
```

### Parallel Dependent Queries

```typescript
// ‚úÖ GOOD - parallel with conditional enabled
const { data: user } = useQuery({ queryKey: ['user', userId], queryFn: () => getUser(userId) })
const { data: posts } = useQuery({
  queryKey: ['posts', userId],
  queryFn: () => getUserPosts(userId),
  enabled: Boolean(user),
})

// ‚ùå BAD - sequential waterfall
useEffect(() => {
  if (user) fetchUserPosts(user.id) // Runs after first completes
}, [user])
```

### Prefetching for Anticipated Data

```typescript
const handleRowHover = (routeId: string) => {
  queryClient.prefetchQuery({
    queryKey: ['route-details', routeId],
    queryFn: () => getRouteDetails(routeId),
  })
}
```

## üî¥ CRITICAL: Bundle Size Optimization

### Lazy Load All Route Components

```typescript
// ‚úÖ REQUIRED
import { lazy, Suspense } from 'react'
const CargoRequestsPage = lazy(() => import('pages/cargo-requests'))
const DashboardPage = lazy(() => import('pages/dashboard'))

const Router = () => (
  <Suspense fallback={<Spin />}>
    <Routes>
      <Route path="/cargo" element={<CargoRequestsPage />} />
      <Route path="/dashboard" element={<DashboardPage />} />
    </Routes>
  </Suspense>
)
```

### Dynamic Imports for Heavy Components

```typescript
// ‚úÖ GOOD
const HeavyChart = lazy(() => import('shared/ui/HeavyChart'))
<Suspense fallback={<Spin />}><HeavyChart data={data} /></Suspense>

// ‚ùå BAD
import { HeavyChart } from 'shared/ui/HeavyChart' // Loaded immediately
```

### Avoid Barrel File Imports

**Impact: CRITICAL (200-800ms import cost)**

```typescript
// ‚ùå BAD - imports entire library (1,583 modules)
import { Check, X, Menu } from 'lucide-react'

// ‚úÖ GOOD - direct imports (3 modules)
import Check from 'lucide-react/dist/esm/icons/check'
import X from 'lucide-react/dist/esm/icons/x'
import Menu from 'lucide-react/dist/esm/icons/menu'
```

**Libraries affected:** `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`.

### Defer Non-Critical Third-Party Libraries

```typescript
// ‚úÖ GOOD - loads after hydration
const Analytics = lazy(() => import('@vercel/analytics/react').then(m => m.Analytics))
<Suspense fallback={null}><Analytics /></Suspense>

// ‚ùå BAD - blocks initial bundle
import { Analytics } from '@vercel/analytics/react'
```

### Conditional Module Loading

```typescript
// ‚úÖ GOOD - load only when feature enabled
useEffect(() => {
  if (enabled && !frames && typeof window !== 'undefined') {
    import('./animation-frames.js').then((mod) => setFrames(mod.frames))
  }
}, [enabled, frames])
```

### Preload Based on User Intent

```typescript
// ‚úÖ GOOD - preload on hover/focus
const preload = () => {
  if (typeof window !== 'undefined') {
    void import('./monaco-editor')
  }
}

<button onMouseEnter={preload} onFocus={preload} onClick={onClick}>
  Open Editor
</button>
```

## üü° HIGH: Re-render Optimization

### Extract to Memoized Components

```typescript
// ‚ùå BAD - computes even when loading
function Profile({ user, loading }: Props) {
  const avatar = useMemo(() => <Avatar id={computeAvatarId(user)} />, [user])
  if (loading) return <Skeleton />
  return <div>{avatar}</div>
}

// ‚úÖ GOOD - skips computation when loading
const UserAvatar = memo(({ user }: { user: User }) => {
  const id = useMemo(() => computeAvatarId(user), [user])
  return <Avatar id={id} />
})

function Profile({ user, loading }: Props) {
  if (loading) return <Skeleton />
  return <div><UserAvatar user={user} /></div>
}
```

### Defer State Reads to Usage Point

```typescript
// ‚ùå BAD - subscribes to all changes
function ShareButton({ chatId }: { chatId: string }) {
  const searchParams = useSearchParams()
  const handleShare = () => shareChat(chatId, { ref: searchParams.get('ref') })
  return <button onClick={handleShare}>Share</button>
}

// ‚úÖ GOOD - reads on demand
function ShareButton({ chatId }: { chatId: string }) {
  const handleShare = () => {
    const ref = new URLSearchParams(window.location.search).get('ref')
    shareChat(chatId, { ref })
  }
  return <button onClick={handleShare}>Share</button>
}
```

### Functional setState Updates

```typescript
// ‚ùå BAD - requires state dependency
const addItems = useCallback(
  (newItems: Item[]) => {
    setItems([...items, ...newItems])
  },
  [items],
) // Recreated on every items change

// ‚úÖ GOOD - stable callback
const addItems = useCallback((newItems: Item[]) => {
  setItems((curr) => [...curr, ...newItems])
}, []) // No dependencies needed
```

### Lazy State Initialization

```typescript
// ‚ùå BAD - runs on every render
const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))

// ‚úÖ GOOD - runs only once
const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))
```

### Transitions for Non-Urgent Updates

```typescript
// ‚ùå BAD - blocks UI
const handler = () => setScrollY(window.scrollY)

// ‚úÖ GOOD - non-blocking
import { startTransition } from 'react'
const handler = () => startTransition(() => setScrollY(window.scrollY))
```

### Subscribe to Derived State

```typescript
// ‚ùå BAD - re-renders on every pixel change
const width = useWindowWidth() // updates continuously
const isMobile = width < 768

// ‚úÖ GOOD - re-renders only when boolean changes
const isMobile = useMediaQuery('(max-width: 767px)')
```

### Narrow Effect Dependencies

```typescript
// ‚ùå BAD - re-runs on any user field change
useEffect(() => {
  console.log(user.id)
}, [user])

// ‚úÖ GOOD - re-runs only when id changes
useEffect(() => {
  console.log(user.id)
}, [user.id])
```

## üü° HIGH: Rendering Performance

### Virtualize Large Lists

```typescript
// ‚úÖ GOOD - virtual scroll (100+ items)
<MaterialReactTable
  columns={columns}
  data={largeDataset}
  enableVirtualization
  virtualizerProps={{ overscan: 20 }}
/>

// ‚ùå BAD - renders all rows
<Table dataSource={largeDataset} />
```

### CSS content-visibility for Long Lists

```css
.message-item {
  content-visibility: auto;
  contain-intrinsic-size: 0 80px;
}
```

For 1000 messages, browser skips layout/paint for ~990 off-screen items (10√ó faster).

### Batch DOM CSS Changes

```typescript
// ‚ùå BAD - multiple reflows
element.style.width = '100px'
element.style.height = '200px'
element.style.backgroundColor = 'blue'

// ‚úÖ GOOD - single reflow
element.classList.add('highlighted-box')
// OR
element.style.cssText = 'width: 100px; height: 200px; background-color: blue;'
```

### Hoist Static JSX Elements

```typescript
// ‚ùå BAD - recreates every render
function Container() {
  return <div>{loading && <LoadingSkeleton />}</div>
}

// ‚úÖ GOOD - reuses same element
const loadingSkeleton = <div className="animate-pulse h-20 bg-gray-200" />
function Container() {
  return <div>{loading && loadingSkeleton}</div>
}
```

### Explicit Conditional Rendering

```typescript
// ‚ùå BAD - renders "0" when count is 0
{count && <span className="badge">{count}</span>}

// ‚úÖ GOOD
{count > 0 ? <span className="badge">{count}</span> : null}
```

## üü° HIGH: Avoid Over-Fetching

### Fetch Only Required Fields

```typescript
// ‚úÖ GOOD
const { data: user } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId, { fields: ['id', 'name', 'email'] }),
})

// ‚ùå BAD - fetches 50+ fields, uses 3
const { data: user } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId),
})
```

### Server-Side Pagination

```typescript
// ‚úÖ GOOD - fetches only 20 items
const { data } = useQuery({
  queryKey: ['items', pagination],
  queryFn: () => getItems(pagination),
})

// ‚ùå BAD - fetches 10,000+ items
const { data: allItems } = useQuery({
  queryKey: ['items', 'all'],
  queryFn: () => getAllItems(),
})
```

## üü¢ LOW-MEDIUM: JavaScript Performance

### Set/Map for O(1) Lookups

```typescript
// ‚ùå BAD - O(n) per check
const allowedIds = ['a', 'b', 'c']
items.filter((item) => allowedIds.includes(item.id))

// ‚úÖ GOOD - O(1) per check
const allowedIds = new Set(['a', 'b', 'c'])
items.filter((item) => allowedIds.has(item.id))
```

### Build Index Maps for Repeated Lookups

```typescript
// ‚ùå BAD - O(n) per lookup
orders.map((order) => ({
  ...order,
  user: users.find((u) => u.id === order.userId),
}))

// ‚úÖ GOOD - O(1) per lookup
const userById = new Map(users.map((u) => [u.id, u]))
orders.map((order) => ({
  ...order,
  user: userById.get(order.userId),
}))
```

### Use toSorted() Instead of sort()

```typescript
// ‚ùå BAD - mutates array
const sorted = useMemo(() => users.sort((a, b) => a.name.localeCompare(b.name)), [users])

// ‚úÖ GOOD - creates new array
const sorted = useMemo(() => users.toSorted((a, b) => a.name.localeCompare(b.name)), [users])
```

### Loop for Min/Max Instead of Sort

```typescript
// ‚ùå BAD - O(n log n)
const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)
return sorted[0]

// ‚úÖ GOOD - O(n)
let latest = projects[0]
for (let i = 1; i < projects.length; i++) {
  if (projects[i].updatedAt > latest.updatedAt) latest = projects[i]
}
return latest
```

### Stable Object References

```typescript
// ‚úÖ GOOD - memoized config
const tableOptions = useMemo(() => ({
  enableRowSelection: true,
  enableColumnFilters: true,
}), [])

<MaterialReactTable options={tableOptions} />

// ‚ùå BAD - new object every render
<MaterialReactTable options={{ enableRowSelection: true }} />
```

### Cache Storage API Calls

```typescript
// ‚ùå BAD - reads storage on every call
function getTheme() {
  return localStorage.getItem('theme') ?? 'light'
}

// ‚úÖ GOOD - Map cache
const storageCache = new Map<string, string | null>()
function getLocalStorage(key: string) {
  if (!storageCache.has(key)) {
    storageCache.set(key, localStorage.getItem(key))
  }
  return storageCache.get(key)
}
```

### Combine Multiple Array Iterations

```typescript
// ‚ùå BAD - 3 iterations
const admins = users.filter((u) => u.isAdmin)
const testers = users.filter((u) => u.isTester)
const inactive = users.filter((u) => !u.isActive)

// ‚úÖ GOOD - 1 iteration
const admins: User[] = []
const testers: User[] = []
const inactive: User[] = []
for (const user of users) {
  if (user.isAdmin) admins.push(user)
  if (user.isTester) testers.push(user)
  if (!user.isActive) inactive.push(user)
}
```

## Profiling Tools (React DevTools 5.x)

### React DevTools Profiler

```bash
# Enable profiler in production builds (Vite)
# vite.config.ts
export default defineConfig({
  define: {
    __REACT_DEVTOOLS_GLOBAL_HOOK__: '({ isDisabled: false })',
  },
})
```

**Key metrics to watch:**

- **Commit duration** - time React spent rendering
- **Render count** - components re-rendered per commit
- **Why did this render?** - identifies unnecessary re-renders

### React Compiler Debugging

```typescript
// Check if component is optimized by Compiler
// In DevTools, optimized components show "Memo ‚úì" badge

// Force Compiler to skip optimization (debugging)
// @ts-expect-error - debugging directive
'use no memo'
function ComponentToDebug() {
  // ...
}
```

### Performance Timeline Integration

```typescript
// Mark performance boundaries for DevTools Timeline
import { unstable_trace as trace } from 'scheduler/tracing'

function handleClick() {
  trace('button click', performance.now(), () => {
    // Action to trace
  })
}
```

### INP Debugging

```typescript
// Measure Interaction to Next Paint
new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.name === 'click' || entry.name === 'keydown') {
      console.log(`INP candidate: ${entry.duration}ms`, entry)
    }
  }
}).observe({ type: 'event', buffered: true, durationThreshold: 16 })
```

## Code Review Checklist

### React 19 & Compiler

- [ ] React Compiler enabled (check for "Memo ‚úì" badges in DevTools)
- [ ] Server Components used for static content
- [ ] Client Components only for interactive parts
- [ ] `use()` hook for async data instead of useEffect+useState
- [ ] `useActionState` for form submissions
- [ ] `useOptimistic` for instant feedback UI
- [ ] Suspense boundaries at appropriate granularity

### Bundle & Loading

- [ ] All route components lazy loaded
- [ ] Heavy components dynamically imported
- [ ] No barrel file imports (direct imports)
- [ ] Non-critical libraries deferred

### Data Fetching

- [ ] No sequential independent awaits (use Promise.all)
- [ ] Independent queries use parallel useQuery
- [ ] Fetching only required fields
- [ ] Server-side pagination for large datasets
- [ ] Prefetching on hover/focus for anticipated navigation

### Rendering

- [ ] Large lists (100+ items) use virtualization or content-visibility
- [ ] DOM CSS changes batched (classes or cssText)
- [ ] Stable object references for memoized components
- [ ] Functional setState for state-dependent updates
- [ ] Lazy state initialization for expensive values
- [ ] Narrow effect dependencies (primitives, not objects)
- [ ] Subscribe to derived booleans, not continuous values
- [ ] `startTransition` for non-urgent updates (improves INP)

## Performance Budgets

| Metric       | Target  | Warning   | Critical |
| ------------ | ------- | --------- | -------- |
| Main bundle  | < 200KB | 200-300KB | > 300KB  |
| Vendor chunk | < 150KB | 150-200KB | > 200KB  |
| Route chunk  | < 100KB | 100-150KB | > 150KB  |
| Initial JS   | < 300KB | 300-400KB | > 400KB  |
