---
description: 'FSD architecture, layered patterns, SOLID principles, dependency injection'
globs: ['**/app/**/*.ts', '**/app/**/*.tsx', '**/pages/**/*.tsx']
alwaysApply: false
---

# Architecture Guidelines

## Overview

Architecture guidelines and patterns for this project.

## Core Architecture Principles

### FSD (Feature-Sliced Design)

```mermaid
graph TB
    subgraph src[" src/ "]
        app[app/<br/>Entry, providers, router]
        pages[pages/<br/>Route pages]
        widgets[widgets/<br/>Cross-page UI]
        shared[shared/<br/>api/, ui/, utils/]
        entities[entities/<br/>Domain entities]
    end

    app --> pages
    pages --> widgets
    widgets --> shared
    widgets --> entities
    entities --> shared
```

### Layered Architecture

```mermaid
graph TB
    subgraph Presentation["Presentation Layer"]
        C[Components]
        P[Pages]
        W[Widgets]
    end

    subgraph Business["Business Logic Layer"]
        S[Services]
        UC[Use Cases]
        R[Repositories]
    end

    subgraph Data["Data Layer"]
        API[API Clients]
        DS[Data Sources]
        M[Models]
    end

    Presentation --> Business
    Business --> Data
```

## Design Patterns

### Dependency Injection

```ts
class Service {
  constructor(private repository: Repository) {}
}

// Usage
const service = new Service(new Repository())
```

### Repository Pattern

```ts
interface Repository {
  getById(id: string): Promise<Entity>
  save(entity: Entity): Promise<Entity>
}

class EntityRepository implements Repository {
  getById(id: string): Promise<Entity> {
    // Implementation
  }

  save(entity: Entity): Promise<Entity> {
    // Implementation
  }
}
```

### Service Layer

```ts
class UserService {
  constructor(private userRepository: UserRepository) {}

  async getUser(id: string): Promise<User> {
    return this.userRepository.getById(id)
  }
}
```

## Best Practices

### Modularity

- Keep modules focused on single responsibility
- Minimize dependencies between modules
- Use clear interfaces
- Follow SOLID principles

### Scalability

- Design for future growth
- Use abstractions
- Avoid tight coupling
- Plan for extensibility

### Maintainability

- Write clear documentation
- Use consistent patterns
- Keep code readable
- Follow coding standards

## Technology Stack Integration

### Frontend

- **React**: Component-based UI
- **TypeScript**: Type safety
- **Vite**: Build tool
- **Ant Design**: UI components

### Backend Integration

- **API Client**: Orval generated clients
- **State Management**: TanStack Query, Zustand
- **Authentication**: Azure AD OAuth 2.0

## Related

- @tech-stack - Technology stack details
- @architecture - React patterns that follow architecture
- @quality - Quality rules that enforce architecture compliance
