---
description: 'Search existing solutions before custom implementations - Context7, codebase, deps'
globs: ['**/features/**/*.ts', '**/features/**/*.tsx', 'scripts/**/*.ts']
alwaysApply: false
---

# Use Existing Solutions First

## Critical Rule

**NEVER create custom implementations when proven solutions exist.**

## Mandatory Workflow

### Before Implementing ANY Feature or Tool

**1. Plan with Beads** (MANDATORY):

```bash
# Create Epic for multi-step work
EPIC=$(bd create "Epic: [Feature Title]" --type=epic -p 1)
# Decompose into tasks
bd create "Research: [topic]" --deps epic:$EPIC -p 1
bd create "Implement: [component]" --deps epic:$EPIC -p 2
```

**2. Search for existing solutions (MANDATORY):**

```typescript
// ✅ CORRECT workflow
// Step 1: Search for existing solutions
CallMcpTool({
  server: "user-MCP_DOCKER",
  toolName: "resolve-library-id",
  arguments: { libraryName: "<your-problem-domain>" }
})

// Step 2: Get documentation for top result
CallMcpTool({
  server: "user-MCP_DOCKER",
  toolName: "get-library-docs",
  arguments: {
    context7CompatibleLibraryID: "/<org>/<library>",
    topic: "setup",
    tokens: 5000
  }
})

// Step 3: Use existing solution from search results

// ❌ WRONG workflow
// Creating custom scripts without searching first
```

**2. Search order (MCP-first approach):**

1. **Beads** - Check active/in-progress tasks and previous work

   - Use `bd ready --json` to check ready work
   - Use `bd list --status=open` to check all open tasks
   - Use `bd show <id> --json` to get full context from task descriptions
   - Look for: previous research, analysis reports, similar tasks in task descriptions

2. **Context7 MCP** - Find libraries and tools (PRIORITY, used daily)
   - Use `resolve-library-id` to find libraries
   - Use `get-library-docs` for documentation
   - Server: `MCP_DOCKER`
3. **Hindsight MCP** - Recall previous experience, opinions, memories, and patterns
   - Use `recall` to find: previous experience with similar tasks, opinions on solutions, memories of what worked/didn't work
   - **Memories**: What was done before, sequence of events, decisions made
   - **Experience**: How things were done, what worked well, what didn't work, practical knowledge
   - **Opinions**: Preferences, decisions, approaches, "why we do it this way", team consensus, trade-offs considered
   - **Patterns**: Coding patterns, architectural decisions, reusable solutions
   - **Lessons**: What was learned, what to avoid, mistakes and their solutions
   - Search banks: `patterns` (coding patterns), `lessons` (lessons learned), `alice` (general memory)
   - Server: `user-hindsight-alice`
   - See: @hindsight for detailed usage
4. **Web search** - Find best practices and comparisons (if MCP doesn't have answer)
5. **Project dependencies** - Check `package.json` for existing tools
6. **Project documentation** - Check `docs/` and AI rules directory
7. **Codebase search** - Check if similar functionality exists

**Note**: MCP tools are priority. Beads and Hindsight provide project-specific context (research, experience, opinions, memories) that external search cannot provide. Use web search and other methods only if MCP doesn't provide sufficient information.

**3. Study library documentation BEFORE implementing custom logic:**

**CRITICAL**: Before writing custom code to solve a problem, check if the library already provides the feature:

- ✅ **Read official documentation** - Check built-in features, options, configuration
- ✅ **Search for examples** - Look for common patterns and best practices
- ✅ **Check transport/plugin ecosystem** - Many libraries have official/community extensions
- ✅ **Review API reference** - Look for configuration options that solve your need

**Pattern**: Trust the ecosystem. Libraries are designed to handle common use cases. Only add custom logic if there's a genuine gap.

**4. Only create custom solutions if:**

- ❌ No suitable library/tool exists after thorough search
- ❌ Library doesn't provide the needed feature (after studying documentation)
- ❌ Existing solutions don't meet specific requirements
- ❌ Custom solution is explicitly requested by user

## Examples

| Instead of... | Search for... |
|---------------|---------------|
| Custom secret scanner | Existing secret scanning tools via Context7 |
| Custom validation logic | Schema validation libraries in project deps |
| Custom HTTP wrapper | HTTP client already in project dependencies |
| Manual file rotation | Built-in library features (check docs first) |

## Why This Matters

1. **Time efficiency**: Existing solutions are tested, documented, maintained
2. **Quality**: Proven tools have fewer bugs, better performance
3. **Maintainability**: Standard tools are easier for team to understand
4. **Security**: Established tools have security audits and updates
5. **Community support**: Popular tools have active communities

## Common Categories to Search

When searching for existing solutions, consider these categories:

- **Security**: Secret scanning, dependency auditing, code analysis
- **Validation**: Type checking, runtime validation, form validation
- **Testing**: Unit tests, E2E tests, API mocking
- **Build/Tooling**: Bundlers, transpilers, code generators

Use Context7 `resolve-library-id` to find established tools in each category.

## Workflow Checklist

Before implementing ANY feature:

- [ ] Searched context7 for relevant libraries
- [ ] Searched web for best practices
- [ ] Checked project dependencies
- [ ] **Studied library documentation for built-in features** (CRITICAL)
- [ ] **Checked for official/community transports/plugins** (CRITICAL)
- [ ] Reviewed project documentation
- [ ] Checked if similar functionality exists in codebase
- [ ] Documented why custom solution is needed (if created)

## Remember

**If a problem is common, a solution likely already exists. Find it first.**
